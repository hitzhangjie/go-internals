<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go设计实现内幕</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Infrastructure/</link><description>Recent content on Go设计实现内幕</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hitzhangjie.pro/go-internals-v2/docs/Infrastructure/index.xml" rel="self" type="application/rss+xml"/><item><title>what is a goproxy</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Infrastructure/what-is-a-goproxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/Infrastructure/what-is-a-goproxy/</guid><description>Let&amp;rsquo;s summarize # 介绍了goproxy的用途，保证“构建的确定性”和“构建时依赖的可用性”。
public goproxy和private goproxy通过环境变量GOPROXY和GOPRIVATE进行区分，通常我们访问公共的代码库要通过GOPROXY中的配置去获取，而访问公司内私有仓库则访问GOPRIVATE中配置的去访问。
其实就是要获取的module importPath去和GOPRIVATE匹配，匹配成功则走importPath中的域名去拉取，反之则全部走GOPROXY去拉取。
也有中办法通过配置一个集中式的GOPROXY来代替public、private模块请求，它内部再去区分对待，比如JFrog Artifactory，腾讯内部也是自己搭了一个集中的proxy来代理public、private modules所有请求。
Source Analysis # Reference # https://jfrog.com/blog/why-goproxy-matters-and-which-to-pick/'</description></item><item><title>playing with go module proxy</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Infrastructure/playing-with-go-module-proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/Infrastructure/playing-with-go-module-proxy/</guid><description>Let&amp;rsquo;s Summarize # 介绍了goproxy的大致工作原理，根据goproxy protocol的官方设计说明，只要实现go module query必要的那些接口就可以算作是实现了goproxy。 其实我们可以自己实现简单的goproxy，有两个办法：1）因为goproxy protocol支持file://，因此我们可以直接将~/go/pkg/mod/cache/download这个路径设置为GOPROXY=file:///Users//go/pkg/mod/cache/download，这样也可以。2）另一种方法也可以直接启动一个FileServer返回上述目录中的东西，然后将GOPROXY指向这个FileServer监听地址。 要理解为什么这样能工作，其实只需要知道go mod query的过程即可，大致分为这么几步，比如要查询module github.com/a/b@version这个版本：
首先查询这个module的版本的list请求，获取版本列表； 然后根据请求的版本从list结果中选择版本，然后查询info请求，获得该版本的信息； 然后查询mod请求可能检查下有没有更新信息； 然后请求下载module-version.zip，这里面包含了go文件，将来会解压到~/go/pkg/mod/下面。 Source Analysis # References # https://roberto.selbach.ca/go-proxies/</description></item></channel></rss>