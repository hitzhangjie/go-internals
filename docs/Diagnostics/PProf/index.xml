<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PProf on Go设计实现内幕</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Diagnostics/PProf/</link><description>Recent content in PProf on Go设计实现内幕</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hitzhangjie.pro/go-internals-v2/docs/Diagnostics/PProf/index.xml" rel="self" type="application/rss+xml"/><item><title>language semantics on memory profiling</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Diagnostics/PProf/language-semantics-on-memory-profiling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/Diagnostics/PProf/language-semantics-on-memory-profiling/</guid><description>Let&amp;rsquo;s Summarize # Go has some amazing tooling that allows you to understand the decisions the compiler is making as it relates to escape analysis. Based on this information, you can refactor code to be sympathetic with keeping values on the stack that don’t need to be on the heap. You are not going to write zero allocation software but you want to minimize allocations when possible.
That being said, never write code with performance as your first priority because you don’t want to be guessing about performance.</description></item><item><title>samples collection with pprof</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Diagnostics/PProf/samples-collection-with-pprof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/Diagnostics/PProf/samples-collection-with-pprof/</guid><description>Let&amp;rsquo;s Summarize # 介绍了pprof中CPU profile的工作原理，大致过程是，按照一定的采样频率来生成SIGPROF信号，由gsignal协程接收并执行处理，处理逻辑就是去收集必要的数据并写入一个buffer，最好生成报表。
TODO 大致过程是这样的，细节要看下代码。
Source Analysis # References # https://medium.com/a-journey-with-go/go-samples-collection-with-pprof-2a63c3e8a142</description></item></channel></rss>