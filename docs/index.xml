<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go设计实现内幕</title><link>https://hitzhangjie.pro/go-internals-v2/docs/</link><description>Recent content on Go设计实现内幕</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hitzhangjie.pro/go-internals-v2/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>前言</title><link>https://hitzhangjie.pro/go-internals-v2/docs/preface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/preface/</guid><description>前言 # 我们准备做什么 如今，go语言被广泛地应用，相关的分享、书籍也越来越多，从基础到实现细节，《go programming language》、《go语言101》、《go语言设计实现》等。对于高质量的知识分享，“feed me more”可能是很多技术人的同感。当有了一定的沉淀后，是可以靠自己钻研来解惑或答疑的，但能不能系统性地沉淀、由点及面来帮助更多的开发者呢？比如goroutine如何应用、为什么协程好用呢、协程有哪些实现思路、go为何采用现在的方案？融会贯通、给大脑做减法，这就是我们的初衷。 为什么要这么做 钻研计算机技术，需要大量的沉淀积累，学习工作中深刻理解了一点“了解的越多，认识到不懂的也越多”。当尝试了解一个不熟悉的领域时，无异于“跨界”，即便是go test -race这种常见操作，如果不了解并发冲突检测的实现细节，其实也不能算是真的了解的，要理解这些，我们还需要了解点分布式原理的知识（如向量时钟及应用），还有并发冲突检测的框架（如Thread Sanitizer）。当我们能简明扼要地解答一个复杂问题时，就算是真理解了，这样也可以帮助更多人。 准备怎么落地 “一只穿云箭，千军万马来相见”，开源让我感受到了协作分享的力量。我认同凭自身努力深入钻研的过程，但个体时间终究有限，借助高质量的协同能让我们走的更快更远。所以不准备从零到一来写本电子书，日常学习工作中也收集了一些质量很高的文章（当然也有自己写的），这些有价值的信息就这么散落在各个角落，非常有必要将其“串”起来。另外出版书籍更新慢、知识覆盖受限，很多书推敲起来内容会略显单薄，协作、有经验甚至“跨界”的协作者能参与进来，有助于知识由点及面。 和Go语言的相识 # go语言并不是我接触的第一门编程语言，当我第一次了解这门语言还是在2016年，和c语言比较起来其“怪异”的语法让我很不习惯，工作之后，使用的服务框架对协程支持的局限性让我重新开始接触go语言，那个时候我还是倾向于c/c++/java开发的，对go甚至有种抵触。我宁可去钻研libmill、libdill、boost coroutine、kilim、qusar等，也不想去琢磨go？原因仅仅是觉得它的语法有点怪异 😂
这个过程持续了一段时间，直到踩的坑越来越多，直到再也不想听“口耳相传”的经验：
服务框架spp有3大件，proxy收包、worker处理、ctrl健康检查，我在worker里加了点可能导致阻塞的系统调用（非网络io），嘿，因为worker阻塞失去心跳被ctrl杀掉了。 服务框架spp协程栈固定大小128k，有个小伙伴在协程处理逻辑内创建了个比较大的局部变量，导致超出协程栈上限，嘿，段错误崩溃了。 服务框架jungle配合kilim字节码织入实现协程，偶尔忘记加@Pausable导致出问题，出了问题排查起来还费劲，嘿，每次被高工指导。 服务框架jungle使用的kilim字节码织入，只支持jdk 1.7字节码，嘿，jdk没法升级了。 这些框架中的微线程实现、字节码织入方案，基本上只是处理了网络io（connect、send、receive、read、write）之类的操作，但是可能导致阻塞的操作远远不止网络io啊，比如锁lock、unlock…嘿，难道用到啥都要hook下？ …… 在我看了spp框架、jungle框架以及字节码织入方案等的局限性之后，我不想再折腾这些了，我开始花更多时间去了解go，这就是我和go语言美好关系的开始。工作中遇到的开发效率的问题、依赖管理的问题、编译构建的问题、代码风格的问题等，最终导致我们团队下定决心转go语言。
我眼中的Go语言 # 在评价go语言之前，想先提下对c语言的评价，曾经有人这样评价c语言：“任何比c语言更低级的语言，都不足以抽象一个完整的计算机系统；任何比c语言更高级的语言，都可以用c语言来实现”。结合我学习过的编程语言来看，汇编、c、c++、java、swift、go、rust、python、php、javascript，仔细琢磨下我认为这样的评价实至名归。
学习软件工程时，我们系统性学习了过程式、面向对象的方法，结合不同编程语言对上虞思想的支持，开始时经验肤浅的我像很多开发者一样，天真的认为缺少某些oo支持的语言是难以架构大型软件的，直到我读了linux内核代码，我才认识到自己的认知多么肤浅。原来，在大佬的世界里，编程思想一直存在，语言只是实现思想的工具而已（linux内核中有非常多oo思想的实践，也有很多对c++ smartpointer的模拟，等等）。
时至今日，再看go语言我已经客观地多，它确实是一门工程化不错的语言：
和c\c++比，它有较好的依赖管理，基本开箱即用的标准库，经得起推敲的代码风格规范，较完整的编译构建、测试、代码分析、性能分析工具，还有更简便易用的并发控制（chan、sync.*、goroutine），其符合大家认知的happens-before关系建立，即便有可能认识不够到位、代码出错的概率也大大下降。
和java比，它不强制面向对象的招式，却也有面向对象思想的支持，组合优于继承，interface的类型断言、转换，以及后续范型支持（尽管现在go1.18版本还有待完善）。另外，同为自动内存管理的语言，和java jvm调优的数不尽的参数比起来，go的GC pacer仅依靠一个变量设置GOGC，如何在一堆参数中获得一个全局最优解的组合，java可能比go调优时控制粒度更细，但是很明显go可以在内存不是什么硬伤的情况下调优更简单。
和rust比，rust的描述性非常强，编译器能力也非常强，如果能忍受编译器的毒打，并深刻理解rust的设计思想之后，rust确实也是不错的，编译器说对那将来跑起来也会对。和服务跑起来后再排查一些难跟踪的错误，rust的优势就会让人觉得很值。但是我们并不是什么开发小白、我们可能要维护的对象也没那么复杂，不否定rust的价值，但是rust和go相比，目前go的能力是我们团队更希望拥有的。
ps：腾讯内部trpc微服务框架实例数，go版本的有2w+，rust版本的只有个位数。
在合适的场景下go非常有价值，如果非要将其用到一些它不擅长的地方，就需要注意了：
嵌入式开发领域，go有GC机制，可能要做类似tinygo的编译器调整、特性裁剪； 超大规模长连接管理，go的默认实现是goroutine per connection模型，连接数多了goroutine数也上来了，goroutine stack、为连接分配的resizable buffer、连接上事件的polling都会成为不可忽略的问题。业界比较好的方案是两级reactor的实现思路，类似地go版本实现gnet； 密集计算的问题，go比较大的优势在于goroutine并发处理，但是goroutine切换有固定的切换时机（网络IO等等），密集计算场景下goroutine切换不符合“预期”，并发处理效率跟不上，可能需要考虑多进程+taskset绑核处理； 其他问题； 在不合适的场景下就需要多考虑、多钻研透一些，需要综合投入产出比慎重考虑，这种情况下其他语言是否更有优势就很值得考虑了。</description></item><item><title>简介</title><link>https://hitzhangjie.pro/go-internals-v2/docs/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/introduction/</guid><description>简介 # Go语言简介 # go语言是由Google设计开发的一种编程语言，说go语言师出名门一点不过分，它的三位设计者 Robert Griesemer, Rob Pike，以及 Ken Thompson，都是计算机科学技术方面颇有造诣的专家。
Robert Griesemer，1964年生，其主要贡献包括：Chrome V8 Javascript引擎、Sawzall语言、Java Hotspot虚拟机、Strongtalk（在smalltalk上增加了一些强类型检查支持）； Rob Pike，1956年生，其主要贡献包括：分布式操作系统Plan9、分布式操作系统Inferno、编程语言Limbo； Ken Thompson，1943年生，Unix操作系统、B语言、和Dennis Ritchie共同发明的C语言、分布式操作系统Plan9； go设计时吸收了其他编程语言的经验、教训，最终呈现出来的是尽可能实用高效的特性：
支持静态类型的编译型语言 see go programming language；
类似c语言的简洁的语法 see go spec；
更好的内存安全性；
支持动态内存管理，更简单的GC调优控制；
支持结构化类型 see types checking；
支持通信串行处理风格的并发编程模式。
go语言深受广大开发者喜爱，在 TIOBE 2021编程语言排名上位列第13名，但是我们限定下使用场景的话，强类型、编译型语言、网络服务、大型分布式系统，实际上Go的排名会更加亮眼。结合自己C\C++\Java开发体验来看，go语言无疑是一门不错的编程语言。
Jul 2022 Jul 2021 Change Programming Language Ratings Change 1 3 Python 13.</description></item><item><title>准备</title><link>https://hitzhangjie.pro/go-internals-v2/docs/setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/setup/</guid><description>准备 # 在深入学习go语言设计实现过程中，少不了要去阅读些源码，有时还要修改源码并测试，因此掌握基本的go语言开发设置是有必要的，这样会让我们的学习过程事半功倍。
QA: 为什么要读源码？ 我们可以看别人画图并伴有系统性总结的文章、书籍，但要知道从源码翻译成图解是个技术活，从图解实现成源码也是一个技术活，学习go设计实现相当于我们在既有的工程中学习，有些东西别人未必会尝试将其翻译成图解。如果一味寄希望于接收别人咀嚼过的东西，久而久之，会削弱自己独立寻求答案的能力。 本书参考他人的总结，是为了追求更快、更全面的知识覆盖，我们在学习过程中还是要脚踏实地一点，看完别人总结后，可以去翻翻源码求证下。 如果是对编程语言设计实现有深厚的积累的同学，那就另当别论了。
环境设置 # 安装必要工具 # 安装git
比如macOS下可以通过homebrew安装，brew install git
安装go
一般go开发人员已经安装过go语言支持组件了，没有的话下载最新版安装即可
这里的安装设置力求简单，实际上从源码构建go，使用go1.4（最后一个c语言实现的编译器版本）及其之后的go编译器版本均可以，我们这里就直接用最新版好了。
从源码构建 # 下载源码 # #新建目录用于存放go源码，不与GOROOT混在一起即可 mkdir path/to/goroot #检出源代码 git clone https://github.com/golang/go path/to/goroot 执行构建 # #从源码执行构建 cd path/to/goroot cd src &amp;amp;&amp;amp; all.bash 构建出的可执行程序会存放在path/to/goroot/bin下面，如果想测试可以通过path/to/goroot/bin/go build来对go源码进行编译。
修改源码 # 当我们希望修改源码并进行测试，也需要按照上述过程对path/to/goroot/bin/go进行重新构建，然后再对go源码进行编译、测试。
IDE如何设置 # 如果想方便地阅读源码，设置好IDE是必须的。对于go源码，如果我们直接打开该工程并阅读源码，IDE会提示遇到些错误。最常见的一个错误就是“use of internal package not allowed”，当我们打开源码文件，如果该源码文件import了标准库中internal路径下的包，就会遇到这个错误。</description></item><item><title/><link>https://hitzhangjie.pro/go-internals-v2/docs/SUMMARY/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/SUMMARY/</guid><description>Summary # headless: true bookhidden: true # SUMMARY preface introduction setup Specification [go spec](Specification/go spec.md) Toolchain [instrumentation in go](Toolchain/instrumentation in go.md) Compiler [aliases, simple and efficient](Toolchain/Compiler/aliases, simple and efficient.md) [builds &amp;amp; linker&amp;quot;s timeline](Toolchain/Compiler/builds &amp;amp; linker&amp;quot;s timeline.md) [built-in functions optimizations](Toolchain/Compiler/built-in functions optimizations.md) [how &amp;ldquo;go build&amp;rdquo; works](Toolchain/Compiler/how &amp;ldquo;go build&amp;rdquo; works.md) [how are loops translated to assembly](Toolchain/Compiler/how are loops translated to assembly.</description></item></channel></rss>