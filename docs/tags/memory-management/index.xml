<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>memory management on Go设计实现内幕</title>
    <link>https://hitzhangjie.pro/go-internals-v2/tags/memory-management/</link>
    <description>Recent content in memory management on Go设计实现内幕</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://hitzhangjie.pro/go-internals-v2/tags/memory-management/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>demystifying memory management in modern programming languages</title>
      <link>https://hitzhangjie.pro/go-internals-v2/posts/demystifying-memory-management-in-modern-programming-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/posts/demystifying-memory-management-in-modern-programming-languages/</guid>
      <description>Let&amp;rsquo;s Summarize #  Source Analysis #  References #   https://deepu.tech/memory-management-in-programming/  </description>
    </item>
    
    <item>
      <title>memory management and allocation</title>
      <link>https://hitzhangjie.pro/go-internals-v2/posts/memory-management-and-allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/posts/memory-management-and-allocation/</guid>
      <description>Let&amp;rsquo;s Summarize #  runtime.newobject 分配内存对象，runtime.mallocgc管理堆内存。/// go中堆内存分配分为两种情况，小对象和大对象。/// 小对象，小于32KB，分配时从当前P的mcache中申请，mcache中维护了很多大小不同的mspan（又分为scan和no scan），用完内存后回收也不是真的归还给操作系统，而是标记对应mspan没有使用，后面再讨论如何回收归还给操作系统的问题。如果mcache中内存不够用了，就从全局共享的mcentral来申请对应的空余mspan，如果mcentral中也没有空余的了，则通过mheap申请内存，mheap是向操作系统申请，一次申请一个arena（64位系统下申请64MB，其他4MB），并建立pages和mspan之间的映射关系，然后将其中的mspan交给mcentral使用。绝大多数情况可以通过P.mcache解决，并且是无锁操作，分配效率会比较高。mcache中的mspan大小从8B,16B,32B…到最大32K，一共有70个不同尺寸的class，每个class都对应一个链表，里面mspan大小相同，并且分为scan和no scan两个链表，简化了GC扫描任务。/// 大内存对象分配，超过32KB，直接在mheap中分配。
Source Analysis #  References #   https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44  </description>
    </item>
    
    <item>
      <title>the garbage collection handbook</title>
      <link>https://hitzhangjie.pro/go-internals-v2/posts/the-garbage-collection-handbook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/posts/the-garbage-collection-handbook/</guid>
      <description>Let&amp;rsquo;s Summarize #  Source Analysis #  References #   http://gchandbook.org/  </description>
    </item>
    
    <item>
      <title>visualizing memory management in go</title>
      <link>https://hitzhangjie.pro/go-internals-v2/posts/visualizing-memory-management-in-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/posts/visualizing-memory-management-in-go/</guid>
      <description>Let&amp;rsquo;s Summarize #  介绍了go内存组织、分配、垃圾回收方式，并提供了比较好的配图以及GIF动画来直观解释这些过程。
Source Analysis #  References #   https://deepu.tech/memory-management-in-golang/  </description>
    </item>
    
  </channel>
</rss>
