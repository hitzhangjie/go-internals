<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mechanics on Go设计实现内幕</title>
    <link>https://hitzhangjie.pro/go-internals-v2/tags/mechanics/</link>
    <description>Recent content in mechanics on Go设计实现内幕</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://hitzhangjie.pro/go-internals-v2/tags/mechanics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>design philosophy on data and semantics</title>
      <link>https://hitzhangjie.pro/go-internals-v2/posts/design-philosophy-on-data-and-semantics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/posts/design-philosophy-on-data-and-semantics/</guid>
      <description>Let&amp;rsquo;s Summarize #  “Value semantics keep values on the stack, which reduces pressure on the Garbage Collector (GC). However, value semantics require various copies of any given value to be stored, tracked and maintained. Pointer semantics place values on the heap, which can put pressure on the GC. However, pointer semantics are efficient because only one value needs to be stored, tracked and maintained.” - Bill Kennedy
A consistent use of value/pointer semantics, for a given type of data, is critical if you want to maintain integrity and readability throughout your software.</description>
    </item>
    
    <item>
      <title>language mechanics on stacks and pointers</title>
      <link>https://hitzhangjie.pro/go-internals-v2/posts/language-mechanics-on-stacks-and-pointers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/posts/language-mechanics-on-stacks-and-pointers/</guid>
      <description>Let&amp;rsquo;s Summarize #  to pass by value, to share by pointers.
Source Analysis #  References #   https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html  </description>
    </item>
    
    <item>
      <title>language semantics on escape analysis</title>
      <link>https://hitzhangjie.pro/go-internals-v2/posts/language-semantics-on-escape-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/posts/language-semantics-on-escape-analysis/</guid>
      <description>Let&amp;rsquo;s Summarize #  Anytime a value is shared outside the scope of a function’s stack frame, it will be placed (or allocated) on the heap.
The construction of a value doesn’t determine where it lives. Only how a value is shared will determine what the compiler will do with that value. Anytime you share a value up the call stack, it is going to escape. There are other reasons for a value to escape which you will explore in the next post.</description>
    </item>
    
    <item>
      <title>language semantics on memory profiling</title>
      <link>https://hitzhangjie.pro/go-internals-v2/posts/language-semantics-on-memory-profiling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/posts/language-semantics-on-memory-profiling/</guid>
      <description>Let&amp;rsquo;s Summarize #  Go has some amazing tooling that allows you to understand the decisions the compiler is making as it relates to escape analysis. Based on this information, you can refactor code to be sympathetic with keeping values on the stack that don’t need to be on the heap. You are not going to write zero allocation software but you want to minimize allocations when possible.
That being said, never write code with performance as your first priority because you don’t want to be guessing about performance.</description>
    </item>
    
  </channel>
</rss>
