<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go设计实现内幕</title>
    <link>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/</link>
    <description>Recent content on Go设计实现内幕</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>demystifying memory management in modern programming languages</title>
      <link>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/demystifying-memory-management-in-modern-programming-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/demystifying-memory-management-in-modern-programming-languages/</guid>
      <description>Let&amp;rsquo;s Summarize #  Source Analysis #  References #    https://deepu.tech/memory-management-in-programming/  </description>
    </item>
    
    <item>
      <title>memory management and allocation</title>
      <link>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/memory-management-and-allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/memory-management-and-allocation/</guid>
      <description>Let&amp;rsquo;s Summarize #  runtime.newobject 分配内存对象，runtime.mallocgc管理堆内存。/// go中堆内存分配分为两种情况，小对象和大对象。/// 小对象，小于32KB，分配时从当前P的mcache中申请，mcache中维护了很多大小不同的mspan（又分为scan和no scan），用完内存后回收也不是真的归还给操作系统，而是标记对应mspan没有使用，后面再讨论如何回收归还给操作系统的问题。如果mcache中内存不够用了，就从全局共享的mcentral来申请对应的空余mspan，如果mcentral中也没有空余的了，则通过mheap申请内存，mheap是向操作系统申请，一次申请一个arena（64位系统下申请64MB，其他4MB），并建立pages和mspan之间的映射关系，然后将其中的mspan交给mcentral使用。绝大多数情况可以通过P.mcache解决，并且是无锁操作，分配效率会比较高。mcache中的mspan大小从8B,16B,32B…到最大32K，一共有70个不同尺寸的class，每个class都对应一个链表，里面mspan大小相同，并且分为scan和no scan两个链表，简化了GC扫描任务。/// 大内存对象分配，超过32KB，直接在mheap中分配。
Source Analysis #  References #    https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44  </description>
    </item>
    
    <item>
      <title>memory management and memory sweep</title>
      <link>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/memory-management-and-memory-sweep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/memory-management-and-memory-sweep/</guid>
      <description>Let&amp;rsquo;s Summarize #  未被引用的内存对象被垃圾回收器回收后可以用于后续分配新对象，在GC过程中，sweep阶段就是将标记为未使用的内存空间进行清理，清理后得到的空闲内存可以用来分配新的内存对象。/// go在分配对象所需内存空间时，会进行内存清零操作，将对应bits清零以避免残留垃圾值。/// go如何得知哪些内存有使用哪些没有使用呢？go在每个span内部都维护了一个allocBits，gcmarkBits，这两个字段数据结构完全一样，前者记录当前mspan内哪些内存被分配了，后者GC过程中记录哪些内存被引用了，mark termination阶段把allocBits指向gcMarkBits就完成了内存的释放，妙不！
Source Analysis #  References #    https://medium.com/a-journey-with-go/go-memory-management-and-memory-sweep-cc71b484de05  </description>
    </item>
    
    <item>
      <title>slice and memory management</title>
      <link>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/slice-and-memory-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/slice-and-memory-management/</guid>
      <description>Let&amp;rsquo;s Summarize #  slice其结构用slice header来表示，包含data、len、cap 3个字段，这个很多文章提过了，现在提下slice操作中对内存操作方面的一点优化：
 Copy：如果要删除slice nums中索引位置x中的元素，可以通过copy([x:],[x+1:])，然后x=[x:len(x)-1]来完成，也可以通过x = append(x[:x],[x+1:])来完成，这里会涉及到个别索引位置overlap的问题，编译器会转换成使用runtime.memmove来处理，这个函数会解决overlap的情况，比如从头拷贝会覆盖的话就用从后面拷贝来解决，实现稍复杂； Reset：有时一个slice被复用，复用之前希望清空它，可以写一个for循环把对应元素全部清0，我们可以这么写，编译器1.5之后会识别此类代码并将其转换为runtime.memclr*函数，这个效率比较高，应该是类似于memset之类的吧。 Allocate &amp;amp; Copy：其实新创建完一个slice时都会清0也是用的memclr*函数。如果是新创建完(make)之后立即跟着一个copy语句怎么办，那么清零就有点多余了，编译器也会识别这种情况，这种就不清零了。  go编译器一直在演进，让这门语言变得更加&amp;quot;聪明&amp;quot;！
Source Analysis #  References #    https://medium.com/a-journey-with-go/go-slice-and-memory-management-670498bb52be?source=---------4-----------------------  </description>
    </item>
    
    <item>
      <title>visualizing memory management in go</title>
      <link>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/visualizing-memory-management-in-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitzhangjie.pro/go-internals-v2/docs/Memory/MemoryAllocation/visualizing-memory-management-in-go/</guid>
      <description>Let&amp;rsquo;s Summarize #  介绍了go内存组织、分配、垃圾回收方式，并提供了比较好的配图以及GIF动画来直观解释这些过程。
Source Analysis #  References #    https://deepu.tech/memory-management-in-golang/  </description>
    </item>
    
  </channel>
</rss>
