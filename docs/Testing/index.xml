<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go设计实现内幕</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Testing/</link><description>Recent content on Go设计实现内幕</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hitzhangjie.pro/go-internals-v2/docs/Testing/index.xml" rel="self" type="application/rss+xml"/><item><title>learn-go-with-tests</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Testing/learn-go-with-tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/Testing/learn-go-with-tests/</guid><description>Let&amp;rsquo;s Summarize # 通过测试来学习go的使用，掌握tdd测试驱动开发模式。
tdd遵循如下开发模式：
write a test make the compiler pass run test, see that it fails and check the error message is meaningful write enough code to make the test pass refactor tdd遵循上述流程的意义：
write a failing test and see it fail so we know we have written a relevant test for our requirements and seen that it produces an easy to understand description of the failure writing the smallest amount of code to make it pass so we know we have working software then refactor, backed with the safety of our tests to ensure we have well-crafted code that is easy to work with red、green、refactor： throughout this book， we have emphasised the tdd process of:</description></item><item><title>practical fuzzing with go</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Testing/practical-fuzzing-with-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/Testing/practical-fuzzing-with-go/</guid><description>Let&amp;rsquo;s Summarize # fuzzing test，模糊测试，指的是自动构造一些测试用例来进行测试，有助于节省编写测试用例的时间，有助于发现程序中存在的一些不健壮的处理逻辑、bug。
go新版本也将引入fuzzing test功能，到时候可以直接用。现阶段的话，需要借助一些第三方库来针对待测试函数的参数类型来自动构造用例，比如有些库之处自动填充struct中的字段，类似的库有：
https://github.com/bxcodec/faker https://github.com/brianvoe/gofakeit https://github.com/google/gofuzz Source Analysis # References # https://docs.google.com/presentation/d/1KkLrzc8O-dkBQ0itVWcqp3gZbtf_IM6MVfy84FndVlM/edit#slide=id.p</description></item><item><title>unknown parts of the test package</title><link>https://hitzhangjie.pro/go-internals-v2/docs/Testing/unknown-parts-of-the-test-package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals-v2/docs/Testing/unknown-parts-of-the-test-package/</guid><description>Let&amp;rsquo;s Summarize # 1 go test的cache机制
go test引入了cache系统，对于没有改变的代码不会重复执行测试用例，而是会用缓存的上次的测试结果。
go test何时使用cache呢？不只是检查测试的内容有没有变更，也会检查有没有更新环境变量，有没有使用不同的flag，如果有，则不会使用缓存的结果。
如何存储测试结果以及查询应用缓存的测试结果呢？go test对content、环境变量、命令行flags计算hash，计算完成后，存储到$GOCACHE目录下，每个hash对应一个文件，可以通过hexdump -C查看缓存数据。
go test执行时如何绕过cache系统呢，执行GOCACHE=off go test。
2 go test的黑白盒测试
黑盒测试：只关心导出函数的测试，不关心内部实现； 白盒测试：关心内部实现，可以测试导出、非导出函数； 比如hello.go对应package名为hello：
黑盒测试：定义文件hello_test.go，package定义为hello_test； 白盒测试：定义文件hello_test.go，package定义为hello； 3 go test -bench自定义metrics
go test的时候，会输出一些统计数据，比如benchmark的时候可以输出op平均时间、mem allocs的一些数据，也可以通过b.ReportMetric(value float64, desc string)来自定义统计数据展示。
Source Analysis # References # https://medium.com/a-journey-with-go/go-unknown-parts-of-the-test-package-df8988b2ef7f</description></item></channel></rss>