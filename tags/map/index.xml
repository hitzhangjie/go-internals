<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>map on Go设计实现内幕</title><link>https://hitzhangjie.pro/go-internals/tags/map/</link><description>Recent content in map on Go设计实现内幕</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://hitzhangjie.pro/go-internals/tags/map/index.xml" rel="self" type="application/rss+xml"/><item><title>map design by code - part 1</title><link>https://hitzhangjie.pro/go-internals/docs/Builtins/map/map-design-by-code-part-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals/docs/Builtins/map/map-design-by-code-part-1/</guid><description>Let&amp;rsquo;s Summarize # 本文介绍了map的内部数据结构，每个桶8个kvpairs，超过了可以用溢出桶，但是溢出桶会降低map性能，所以会创建新的bucket将数据迁到新bucket里面。/// 一个kvpairs存储在哪个bucket里面呢，首先根据key计算hash，然后对buckets数量取余，再放到对应桶里面，如果有空位置就放入，没有就需要走前面提到的溢出桶的逻辑。/// 根据key计算出的hash除了计算key分布在哪个桶，还有其他用途，每个桶里都有一个top hash构成的数组，是为了map访问时加快查询key所在的数组索引的，通过减少比较key的耗时来加速访问。/// 装填因子，是用来控制map装填的元素数量，即元素数量除以桶数量。装填因子过小容易浪费内存空间，过大容易引发更多的碰撞冲突导致性能下降。
Source Analysis # References # https://medium.com/a-journey-with-go/go-map-design-by-example-part-i-3f78a064a352?source=---------45-----------------------</description></item><item><title>map design by code - part 1</title><link>https://hitzhangjie.pro/go-internals/posts/map-design-by-code-part-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals/posts/map-design-by-code-part-1/</guid><description>Let&amp;rsquo;s Summarize # 本文介绍了map的内部数据结构，每个桶8个kvpairs，超过了可以用溢出桶，但是溢出桶会降低map性能，所以会创建新的bucket将数据迁到新bucket里面。/// 一个kvpairs存储在哪个bucket里面呢，首先根据key计算hash，然后对buckets数量取余，再放到对应桶里面，如果有空位置就放入，没有就需要走前面提到的溢出桶的逻辑。/// 根据key计算出的hash除了计算key分布在哪个桶，还有其他用途，每个桶里都有一个top hash构成的数组，是为了map访问时加快查询key所在的数组索引的，通过减少比较key的耗时来加速访问。/// 装填因子，是用来控制map装填的元素数量，即元素数量除以桶数量。装填因子过小容易浪费内存空间，过大容易引发更多的碰撞冲突导致性能下降。
Source Analysis # References # https://medium.com/a-journey-with-go/go-map-design-by-example-part-i-3f78a064a352?source=---------45-----------------------</description></item><item><title>map design by code - part 2</title><link>https://hitzhangjie.pro/go-internals/docs/Builtins/map/map-design-by-code-part-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals/docs/Builtins/map/map-design-by-code-part-2/</guid><description>Let&amp;rsquo;s Summarize # mapaccess_faststr, mapaccess_fast64&amp;hellip;访问map中元素时，根据key类型不同编译器插入不同的函数调用，函数名后缀表示key的类型，为什么有不同的函数呢？这是为了提高key的hash计算效率和比较效率。/// map提前初始化再赋值，比lazy初始化后再赋值效率高，为什么呢？lazy初始化桶是后面创建的更花时间。但是lazy初始化相比较而言容易节省内存。/// map中kvpairs的存储有考虑内存占用方面的优化，key的类型和value的类型可能不同，所以在数据对齐过程中padding会浪费不少内存，所以go map中的keys和values是分开存储的，先存储keys再存储values。
Source Analysis # References # https://medium.com/a-journey-with-go/go-map-design-by-code-part-ii-50d111557c08</description></item><item><title>map design by code - part 2</title><link>https://hitzhangjie.pro/go-internals/posts/map-design-by-code-part-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hitzhangjie.pro/go-internals/posts/map-design-by-code-part-2/</guid><description>Let&amp;rsquo;s Summarize # mapaccess_faststr, mapaccess_fast64&amp;hellip;访问map中元素时，根据key类型不同编译器插入不同的函数调用，函数名后缀表示key的类型，为什么有不同的函数呢？这是为了提高key的hash计算效率和比较效率。/// map提前初始化再赋值，比lazy初始化后再赋值效率高，为什么呢？lazy初始化桶是后面创建的更花时间。但是lazy初始化相比较而言容易节省内存。/// map中kvpairs的存储有考虑内存占用方面的优化，key的类型和value的类型可能不同，所以在数据对齐过程中padding会浪费不少内存，所以go map中的keys和values是分开存储的，先存储keys再存储values。
Source Analysis # References # https://medium.com/a-journey-with-go/go-map-design-by-code-part-ii-50d111557c08</description></item></channel></rss>